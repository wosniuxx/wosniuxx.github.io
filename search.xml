<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis]]></title>
    <url>%2F2019%2F07%2F27%2Fredis%2F</url>
    <content type="text"><![CDATA[redis 数据结构redis 数据结构底层实现redis 集群搭建redis 项目中实际使用场景redis 淘汰策略redis 过期策略redis 速度快的原因redis 可以用java实现吗？redis 缓存击穿 / 缓存穿透redis 缓存雪崩redis 热点数据redis 性能瓶颈redis memcahce 区别与相似。技术如何选型]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[《深入理解JVM虚拟机》class文件]]></title>
    <url>%2F2018%2F10%2F19%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8Bclass%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[《深入理解JVM虚拟机》 class.java编译后成为.class，江湖人称字节码文件。当虚拟机读取字节码后，转为二进制文件执行代码。那么字节码文件是怎样阅读呢？以及字节码文件在虚拟机中是怎么加载执行呢？这一部分讨论下虚拟机与class文件的关系。 类文件结构[image:B2118612-8559-4534-B532-F0EE059DAE57-21700-0000497937AC42D4/7611B482-6B7D-4E5F-92F9-9745317C2A4E.png] class文件是一组以8位字节为基础单位的二进制流。当遇到占用8位字节以上空间的数据项时，则按照高位在前的方式分割成若干个8位字节存储。class文件格式伪结构体仅有两种数据结构：无符号数和表。 魔数和class文件版本魔数的作用是确定该文件是否时能被虚拟机接受的class文件。位于前4个字节。后4个字节代表class的版本号（5，6次版本号；7，8主版本号）； 常量池常量池在版本号之后，可以理解为class文件的资源仓库。入口是u2类型的数据，代表容量计数器（从1开始计数）。常量池存放数据：字面量，符号引用。字面量较接近java语言的常量概念，如文本字符串，声明为final的常量值。符号引用包括下面三类常量：类和接口的全限定名，字段名称和描述符，方法的名称和描述符。接口索引第一项是接口计数器，表示索引表容量。 访问标志访问标志位于常量池结束后，用于识别一些类和接口层次的访问信息（如class是类还是接口，是否为pulic，是否定义abstract类型） 类索引，父类索引，接口索引集合类索引、父类索引是一个u2类型的数据，接口索引是一组u2类型数据的集合，class文件由这三项来确定这个类的继承关系。类索引确定类的全限定名；父类索引确定该类的父类全限定名，仅有一个（单继承）。接口索引用来描述这个类实现了接口（按照implements顺序排列在集合） 字段表集合字段表用于描述接口或类中声明的变量。包括类级变量以及实例级变量，但不包括方法内局部变量。具体细节包括：字段作用域，类变量或实例变量（static），可变性，并发可见性（volatile）， 是否可被序列化，字段数据类型，字段名称。理解全限定名，简单名称，描述符 方法表集合同字段表类似。方法体存放在一个“code”的属性里面。 PS：重载的理解（JVM）要重载一个方法，除要与原方法具有相同的简单名称外，还要求拥有一个不同的特征签名。特征签名是一个方法中各个参数在常量池中的字段符号引用的集合。由于返回值不会包含在特征签名中，所以Java无法仅依靠返回值不同对一个方法重载。从class角度考虑，两个方法拥有相同的名称和特征签名，但是返回值不同，可以合法存在于同一个class文件。 属性表集合class文件、字段表、方法表均可携带自己的属性表集合，以描述某些场景的专有信息。….好好总结下，这里的内容有点多。。 虚拟机类加载机制虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型。在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的，虽然这样提升增加性能开销，但是提供高度的灵活性。Java可以动态扩展语言特性就是依赖运行期动态加载和动态。 类加载时机加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分被统称为连接。加载、验证、准备、初始化、卸载这几个阶段顺序是确定的，而解析则不一定，某些情况下可以在初始化之后再开始（此处是为了支持Java运行时绑定，反射？）。 加载时机 new、getstatic，putstatic，invokestatic reflect 调用子类时，父类未被初始化 main()所在类 部分解析句柄（jdk1.7支持的动态语言）加载过程加载是”类加载“的一个过程，主要完成三个工作： 通过一个类的全限定名来获取定义该类的二进制字节流 将这个字节流代表的静态存储结构转化为方法区运行时的数据结构 在内存中生成一个代表这个类的class对象，作为方法区中该类的数据访问入口 加载数组类情况有所不同，数组类本身有通过类加载器创建，而是通过虚拟机直接创建。 验证验证阶段目的是为了确保class文件的字节流信息符合当前虚拟机的要求，切不会危害虚拟机安全。从整体上讲，大约分为下面4个方面： 文件格式验证（是否符合class文件格式规范） 元数据验证（语义描述信息符合语言规范） 字节码验证（通过数据流和控制流分析，确定程序合法且符合逻辑） 符号引用验证（对于符号信息进行匹配性校验） 准备准备阶段是将正式为类变量分配内存并设置类变量初始值，这些变量所使用的内存均在方法区进行分配。（1、分配仅包括被static修饰的类变量；2、被final修饰的value会被直接初始化所指定的值） 解析解析是虚拟机将常量池内的符号引用替换为直接饮用的过程。主要对象针对类或接口、字段、类方法、接口方法、方法类型、方法类型、方法句柄和调用点限定符7类进行饮用。 符号引用：符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无奇艺的定位到目标即可。与虚拟机实现的内存布局无关，且引用的目标未必已经加载到内存中。直接引用：直接饮用时可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接饮用是和虚拟机实现的内存布局相关的。如果有了直接饮用，则引用目标必定存在于内存中。 初始化前面的类加载过程，绝大多数是由虚拟机主导和控制。到了初始化阶段，才开始真正执行程序代码（字节码）。执行类构造器()方法。 类加载器通过一个类的全限定名来获取描述此类的二进制字节流，此动作放到Java虚拟机外部实现，改部分代码模块被称为类加载器。 类与类加载器对于任意一个类，都需要由加载该类的类加载器和本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。比较两个类是否“相等”，只有在两个类是由同一个类加载器加载的前提下才有意义。否则即使两个类来源于同一个class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，则这两个类必定不想等。 双亲委派模型从虚拟机角度而言，仅存在两种类加载器。启动类加载器及其他类加载器。启动类加载器是虚拟机的自身的一部分，而其他类加载器则独立于虚拟机外部。在开发人员看来，类加载器可以继续划分。启动类加载器，扩展类加载器，应用程序类加载器。[image:67BB4BDB-358D-4710-A30B-B9CE094833B2-49901-00004FB3BABC266D/A0168939-E93F-4364-9C2A-6BEC4118985A.png] 上图展示的类加载器之间的层次关系，被称之为双亲委派模型。双亲委派模型出了要求顶层的启动类加载器之外，其余类加载器都应当有自己的父类加载器。此处类加载器之间的父子关系并非继承，而是采用组合关系复用类加载器。 双亲委派模型工作原理：如果一个类加载器收到了类加载器的请求，首先并非自己去尝试加载，而是会将请求委派给父类加载器去完成，每一个类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法加载请求，子加载器才会尝试自己去加载。 破坏双亲委派模型第一次被破坏是发生在双亲委派模型出现之前，即jdk1.2发布之前。第二次被破坏时由于模型自身缺陷所导致。双亲委派模型可以很好的将已经加载好的基础类API被用户代码调用的问题。但如果基础类API需要回掉用户代码API，只能使用 “线程上下文类加载器”。原理是父类加载器请求子类加载器去完成加载类的动作。第三次被破坏是由于用户对程序的动态性的追求而导致的。 字节码执行引擎执行引擎是虚拟机最核心的组成部分之一。 运行时的栈帧结构栈帧是用于虚拟机进行方法调用和方法执行的数据结构。是虚拟机栈的栈元素。栈帧储存了方法的局部变量表，操作数帧，动态连接和方法返回等信息。每一个方法从调用开始到执行完成的过程，都对应一个栈帧在虚拟机栈从入栈到出栈的过程。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的被称之为当前栈帧，与该栈帧关联的方法被称之为当前方法。执行引擎运行所有的字节码指令都指针对当前栈帧进行操作。 [image:072C6A7B-9D28-436B-B7B2-9B27D70F4161-49901-00005208F1823246/A4F94359-10A9-4A6D-A90C-507D460456C3.png] 局部变量表局部变量表是一组变量的存储空间，用于存放方法参数和方法内部定义的局部变量。 操作数栈动态连接方法返回地址方法调用基于栈的字节码解释执行引擎]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工作中遇到的问题及反思]]></title>
    <url>%2F2018%2F10%2F12%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E5%8F%8D%E6%80%9D%2F</url>
    <content type="text"><![CDATA[工作中碰到的问题反思及总结感觉最近自己写的bug有点频繁，可能是大脑缺氧了吧。。。这这里罗列出几个比较严重的问题及解决方案，谨记在心同时罗列出工作中的重点、难点以及解决方案，供日后参考 主从数据库数据不同步出现原因：库中数据约30万条，一次性删除约3万条数据，数据库数据开始不同步；解决方案：切换为仅使用主库对外提供服务，从库数据全部清空后开始追回数据，历时约6个小时；影响范围：有2个鬼崽子趁我们未发现主从数据不同步，越过抽奖校验，获取多个抽奖物品； 宝箱落地转化时的幽灵数据问题出现原因：用户点击“领取”时，快速点击多次按钮，发起多次请求。代码中仅考虑事物原子性，未考虑多次请求处理问题，导致两次数据均被处理。数据库中最后记录仅有最后一次有效，但是存在幽灵数据（脏数据）解决方案：使用redis加锁（lock），每次单独处理数据，是的第二次请求无法通过校验数据环节。影响范围：数据审核校验时发现这些幽灵数据（脏数据），未对用户造成影响，但是对数据同步时会有影响。 数据库goods_id错位问题出现原因：抽中流量卡礼包时，错将商品id传入背包表，导致写入数据却显示该礼品卡挂载商品。解决方案：修改代码中的bug，将正确的物品id传入即可；将之前的数据写sql更新影响范围：上线后用户反馈数据出错，排查后发现约3000条数据出错；自我检讨：自己写的bug，阳哥帮我填上……写代码时思路清晰时首要；发现问题后，查明原因及日后预防方案，比匆匆修改错误数据更加重要 并行流在循环中的问题出现原因：用for循环每次读2000条数据并收集，然后再读接下来的2000条，知道读完了退出。当数据量较多后（本次数据量4w+），会出现没有全读完提前退出循环的情况。使用串行流无问题。疑似推测：使用并行流会创建大量线程,造成线程池满了之类的问题,导致程序提前结束了。此处为线程池策略，线程池满后queue（默认时drop)相关资料： https://dzone.com/articles/think-twice-using-java-8https://www.baeldung.com/java-8-parallel-streams-custom-threadpool]]></content>
      <tags>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap 相关理解]]></title>
    <url>%2F2018%2F10%2F11%2FHashMap-%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HashMap, ConcurrentHashMap, HashTablehashing概念哈希散列、哈希算法，根据某个对象生成一串数据 HashMap的工作原理HashMap是基于hashing原理，使用put(),get()存储和读取对象，当使用put()传递key和value时，首先对key调用hashCode()方法，根据返回的hashCode找到bucket中存储Entry对象。注：buctet中存放的是entry对象；当出现hashcode碰撞时，存放该键值对的链表。 HashMap解决碰撞（hashCode碰撞解决办法）当出现hashcode碰撞时，在bucket存放该键值对（entry）的链表。 hashCode碰撞解决办法：开放地址法、拉链法、再次计算哈希值 equals()及hashCode()的应用，已经在HashMap中的重要性hashCode()即比较hashCode的值， equals()比较的是hashCode及对象值；hashMap使用hashCode寻找bucket，如遇到hashcode碰撞，在链表中使用equals()寻找正确的对象。 不可变对象的好处减少比较equals()，提高hashMap的效率。为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。 HashMap重新调整负载因子默认为0.75（75%），HashMap的大小超过了负载因子(load factor)定义的容量，会进行一次rehashing,创建一个原先hashMap两倍大小的map，并将原先对象放入新的bucket中。 HashMap多线程的条件竞争两个线程同时对同一个hashMap进行rehashing时，在调整大小的过程中，储存在链表中的元素次序会反过来，因此移动到新的bucket位置，HashMap并非将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，就会陷入死循环。在jdk8中，已经很好的解决了避免解决尾部遍历的问题，在链表中加入指针，避免每次循环查询链表尾部。 HashMap的底层原理HashMap底层是数组加引用，和链表组成的。当计算hashcode时，通过对象的hashcode值，并且和数组的长度-1做一次与元算。得到的值减少碰撞几率。初始容量为16，负载因子默认0.75容量建议2的n次幂，减少空间浪费，可以使得元素分布更均匀。当容量*负载因子&lt;元素，发生resize写的真牛逼深入理解HashMap - Java综合 - Java - ITeye论坛]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解JVM虚拟机》内存]]></title>
    <url>%2F2018%2F09%2F03%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[有关《深入理解JVM虚拟机》的相关理解可以将书中内容分为几个的知识块来学习。内存： 包括内存模型、内存管理、内存回收JVM与class： class文件结构、类文件加载机制、字节码执行方式多线程与并发： 多线程、线程调度机制、线程安全编译优化 内存我们先来讨论虚拟机中的内存相关信息。在本书中，内存是占据内容的第一版面。正如作者所说，“内存管理者这堵高墙，墙外的人想进来，墙里的人想出去”。我们通常将虚拟姐的内存划分为五块：程序计数区、虚拟机栈、本地方法去、java堆、方法区。其中虚拟机栈、本地方法栈、程序计数器为线程隔离状态，Java堆及方法区则是线程共享区。 程序计数器程序计数器仅占用内存中较小的一块内容，可看为字节码的行号指示器。在概念模型中，字节码解释器通过改变计数器的值来选择接下来执行的字节码指令。Java虚拟机多线程通过线程轮流切换后，分配CPU的执行时间完成。为了线程切换后可以恢复到正确的执行位置，因此每条线程拥有独立，互不影响的程序计数器，我们称之为“线程私有”。 Java虚拟机栈虚拟机栈描述的是java方法执行时的内存模型，生命周期与线程相同。每个方法执行时会创建一个栈帧，用于存放局部变量表、操作数栈、动态链接、方法出口等。方法从调用到结束，队形一个栈帧在虚拟机栈入栈到出栈的过程。 本地方法栈本地方法栈描述的是虚拟机的Native方法运行时的内容从模型，与虚拟机栈类似。 Java堆Java Heap是J虚拟机管理内存中最大的一块，是被所有线程所共享的区域。作用为创建实例对象。（就是被new的对象都放在这里），因此也是内存回收的工作领域，别名GC堆（垃圾堆） 方法区方法区存放虚拟机加载的类信息、常量、静态变量等。运行时常量池是方法区的一部分，用于存放编译器生成的符号引用，这部分内容在类加载后进入运行时常量池。 对象创建、内存布局、访问定位对象创建 1、接收到虚拟机new指令，首先检查指令参数能否定位到类的符号引用，并且检查所在类是否已被加载、解析和初始化。2、虚拟机为对象分配内存，需要了解“空闲列表”（Java堆不规整）以及“指针碰撞”（Java堆工整）3、注意并发时加锁4、将分配的内存空间初始化为零值5、虚拟机设置对象头(类信息、哈希吗、CG年龄) 6、执行方法对象内存布局 对象头、实例数据、对齐填充对象访问定位 使用句柄定位：划分出部分内存作为句柄池，存储对对象的句柄地址（类比数据库索引），GC时对象内存位置改变，仅仅改变句柄指针。使用直接指针：存储地址对象，访问速度更快 OutOfMemoryError（堆溢出、虚拟机栈及本地方法区溢出、方法区溢出、直接内存溢出）Java堆溢出 虚拟机栈和本地方法栈溢出 方法区溢出 直接内存溢出 GC（垃圾回收算法） 对象回收状态什么状态下的对象会被GC回收呢？这部分来探究回收时对象的状态。 引用计数算法（引用新概念）引用概念扩充：强引用（Strong）、软引用（Soft）、弱引用（Weak）、虚引用（Phantom）算法：给对象添加引用计数器，当有地方引用时+1，引用失效时-1。当计数器为0时表示不可再使用。 可达性分析算法通过一系列“GC Roots”的对象作为起始点，从这部分节点开始向下搜索，搜索走过的路径被称之为引用链。当一个对象到GC Roots没有引用链能够到达，证明对象不可用。 对象自救对象死亡需要经过两次标记，无引用链为第一次标记。之后判断对象是否有必要执行finalize()方法，这是第二次标记。因此当对象在第一次标记后，执行finalize()可以暂时留住自己的一条狗命。但是该方法仅可被调用一次，之后不会被执行。（PS：第二次回收时谁也救不了这个对象） 方法区的回收方法区常常被人们称为是永久代。垃圾回收的效率极低。主要回收内容：废弃常量和无用的类。 GC方法集中简单回收的算法思路 标记-清除算法标记出所有需要回收的对象，在完成后回收被标记对象。缺点：1、标记和回收的效率较低2、GC后会产生大量不连续内存碎片，无法容纳大对象，引发第二次GC 复制算法将可用内存按容量分为大小两块。当一块使用完，将存活的对象复制到另一块内存，再将已经使用过的内存一次性清除。优点：不考虑碎片，回收简单，效率高。缺点：内存折半使用，成本太高。 当今复制算法：将内存分为一个Eden和两个Survivor，比例为（8:1:1），每次使用Eden和一块Survivor，当回收时，将Eden和Survivor存活的对象一次性复制到另一块Survivor上，再清除Eden和Survivor。当Survivor不够用时，需要依赖其他内存进行分配担保。 标记-整理算法针对“老年代”，采用标记整理算法。标记过程同之前一样，之后让所有存货对象向一端移动，清理掉边界外的内存。优点：老年代的对象存活较多，不适合复制算法，适合标记整理；碎片较小 分代收集算法新生代：复制算法老年代：标记-整理永久代；标记-整理，标记-清除 垃圾回收器图床有空优化。。。 不用的收集器适用于不同的年龄代；且不同收集器某些才可以互相搭配。具体回收较为复杂。 内存分配策略 对象优先分配在Eden当Eden区空间不够，发起minor GC（新生代GC） 大对象直接进入老年代很长的string或者数组，虚拟机直接让其老年代。 长期存活对象进入老年代每经历一次minor GC，年龄加1。在15岁（默认）后，进入老年代 动态对象年龄判断 空间分配担保]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
